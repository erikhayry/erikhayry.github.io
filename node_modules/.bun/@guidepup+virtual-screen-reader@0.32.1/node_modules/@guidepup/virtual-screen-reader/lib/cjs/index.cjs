"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Virtual: () => Virtual,
  virtual: () => virtual
});
module.exports = __toCommonJS(src_exports);

// src/getIdRefsByAttribute.ts
function getIdRefsByAttribute({
  attributeName,
  node
}) {
  return (node.getAttribute(attributeName) ?? "").trim().split(" ").filter(Boolean);
}

// src/getNodeAccessibilityData/index.ts
var import_html_aria2 = require("html-aria");

// src/getNodeAccessibilityData/getRole.ts
var import_html_aria = require("html-aria");

// src/getLocalName.ts
var getLocalName = (element) => element.localName ?? element.tagName.toLowerCase();

// src/isElement.ts
var ELEMENT_NODE = 1;
function isElement(node) {
  return node.nodeType === ELEMENT_NODE;
}

// src/getNodeAccessibilityData/getRole.ts
var presentationRoles = /* @__PURE__ */ new Set(["presentation", "none"]);
var synonymRolesMap = {
  img: "image",
  presentation: "none",
  directory: "list"
};
var allowedNonAbstractRoles = new Set(import_html_aria.ALL_ROLES);
var rolesRequiringName = /* @__PURE__ */ new Set(["form", "region"]);
var globalStatesAndProperties = [
  "aria-atomic",
  "aria-braillelabel",
  "aria-brailleroledescription",
  "aria-busy",
  "aria-controls",
  "aria-describedby",
  "aria-description",
  "aria-details",
  "aria-dropeffect",
  "aria-flowto",
  "aria-grabbed",
  "aria-hidden",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-live",
  "aria-owns",
  "aria-relevant",
  "aria-roledescription"
];
var FOCUSABLE_SELECTOR = [
  "input:not([type=hidden]):not([disabled])",
  "button:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  '[contenteditable=""]',
  '[contenteditable="true"]',
  "a[href]",
  "[tabindex]:not([disabled])"
].join(", ");
function isFocusable(node) {
  return node.matches(FOCUSABLE_SELECTOR);
}
function hasGlobalStateOrProperty(node) {
  return globalStatesAndProperties.some((global) => node.hasAttribute(global));
}
function mapAliasedRoles(role) {
  const canonical = synonymRolesMap[role];
  return canonical ?? role;
}
function getExplicitRole({
  accessibleName,
  allowedAccessibilityRoles,
  inheritedImplicitPresentational,
  node
}) {
  const rawRoles = node.getAttribute("role")?.trim().split(" ") ?? [];
  const authorErrorFilteredRoles = rawRoles.filter((role) => allowedNonAbstractRoles.has(role)).filter((role) => !!accessibleName || !rolesRequiringName.has(role));
  const isExplicitAllowedChildElement = allowedAccessibilityRoles.some(
    (allowedExplicitRole) => authorErrorFilteredRoles?.[0] === allowedExplicitRole
  );
  if (inheritedImplicitPresentational && !isExplicitAllowedChildElement) {
    authorErrorFilteredRoles.unshift("none");
  }
  if (!authorErrorFilteredRoles?.length) {
    return "";
  }
  const filteredRoles = authorErrorFilteredRoles.filter((role) => {
    if (!presentationRoles.has(role)) {
      return true;
    }
    if (hasGlobalStateOrProperty(node) || isFocusable(node)) {
      return false;
    }
    return true;
  });
  return filteredRoles?.[0] ?? "";
}
function getRole({
  accessibleName,
  allowedAccessibilityRoles,
  inheritedImplicitPresentational,
  node
}) {
  if (!isElement(node)) {
    return { explicitRole: "", implicitRole: "", role: "" };
  }
  const baseExplicitRole = getExplicitRole({
    accessibleName,
    allowedAccessibilityRoles,
    inheritedImplicitPresentational,
    node
  });
  const explicitRole = mapAliasedRoles(baseExplicitRole);
  if ("computedRole" in node) {
    const role = node.computedRole;
    return { explicitRole, implicitRole: role, role };
  }
  const isBodyElement = getLocalName(node) === "body";
  const baseImplicitRole = isBodyElement ? "document" : (0, import_html_aria.getRole)(node, { ignoreRoleAttribute: true })?.name ?? "";
  const implicitRole = mapAliasedRoles(baseImplicitRole);
  if (explicitRole) {
    return { explicitRole, implicitRole, role: explicitRole };
  }
  return {
    explicitRole,
    implicitRole,
    role: implicitRole
  };
}

// src/getNodeAccessibilityData/getAccessibleDescription.ts
var import_dom_accessibility_api = require("dom-accessibility-api");
function getAccessibleDescription(node) {
  return isElement(node) ? (0, import_dom_accessibility_api.computeAccessibleDescription)(node).trim() : "";
}

// src/getNodeAccessibilityData/getAccessibleName.ts
var import_dom_accessibility_api2 = require("dom-accessibility-api");

// src/sanitizeString.ts
function sanitizeString(string2) {
  return string2.trim().replace(/\s+/g, " ");
}

// src/getNodeAccessibilityData/getAccessibleName.ts
function getAccessibleName(node) {
  if ("computedName" in node) {
    return node.computedName;
  }
  return isElement(node) ? (0, import_dom_accessibility_api2.computeAccessibleName)(node).trim() : (
    // `node.textContent` is only `null` for `document` and `doctype`.
    sanitizeString(node.textContent)
  );
}

// src/getNodeAccessibilityData/getAccessibleValue.ts
var ignoredInputTypes = /* @__PURE__ */ new Set(["checkbox", "radio"]);
var allowedLocalNames = /* @__PURE__ */ new Set([
  "button",
  "data",
  "input",
  // "li",
  "meter",
  "option",
  "progress",
  "param"
]);
function getSelectValue(node) {
  const selectedOptions = [...node.options].filter(
    (optionElement) => optionElement.selected
  );
  if (node.multiple) {
    return [...selectedOptions].map((optionElement) => getValue(optionElement)).join("; ");
  }
  if (selectedOptions.length === 0) {
    return "";
  }
  return getValue(selectedOptions[0]);
}
function getInputValue(node) {
  if (ignoredInputTypes.has(node.type)) {
    return "";
  }
  return getValue(node);
}
function getValue(node) {
  const localName = getLocalName(node);
  if (!allowedLocalNames.has(localName)) {
    return "";
  }
  if (node.getAttribute("aria-valuetext") || node.getAttribute("aria-valuenow")) {
    return "";
  }
  return typeof node.value === "number" ? `${node.value}` : node.value;
}
function getAccessibleValue(node) {
  if (!isElement(node)) {
    return "";
  }
  switch (getLocalName(node)) {
    case "input": {
      return getInputValue(node);
    }
    case "select": {
      return getSelectValue(node);
    }
  }
  return getValue(node);
}

// src/isDialogRole.ts
var dialogRoles = /* @__PURE__ */ new Set(["dialog", "alertdialog"]);
var isDialogRole = (role) => dialogRoles.has(role);

// src/getNodeAccessibilityData/index.ts
var childrenPresentationalRoles = new Set(
  Object.entries(import_html_aria2.roles).filter(([, { childrenPresentational }]) => childrenPresentational).map(([key]) => key)
);
var getSpokenRole = ({
  isGeneric,
  isPresentational,
  node,
  role
}) => {
  if (isPresentational || isGeneric) {
    return "";
  }
  if (isElement(node)) {
    const roledescription = node.getAttribute("aria-roledescription");
    if (roledescription) {
      return roledescription;
    }
  }
  return role;
};
var getIsInert = ({
  inheritedImplicitInert,
  node,
  role
}) => {
  if (!isElement(node)) {
    return inheritedImplicitInert;
  }
  const isNativeModalDialog = getLocalName(node) === "dialog" && node.hasAttribute("open");
  const isNonNativeModalDialog = isDialogRole(role) && node.hasAttribute("aria-modal");
  const isModalDialog = isNonNativeModalDialog || isNativeModalDialog;
  const isExplicitInert = node.hasAttribute("inert");
  return isExplicitInert || inheritedImplicitInert && !isModalDialog;
};
function getNodeAccessibilityData({
  allowedAccessibilityRoles,
  inheritedImplicitInert,
  inheritedImplicitPresentational,
  node
}) {
  const accessibleDescription = getAccessibleDescription(node);
  const accessibleName = getAccessibleName(node);
  const accessibleValue = getAccessibleValue(node);
  const { explicitRole, implicitRole, role } = getRole({
    accessibleName,
    allowedAccessibilityRoles,
    inheritedImplicitPresentational,
    node
  });
  const amendedAccessibleDescription = accessibleDescription === accessibleName ? "" : accessibleDescription;
  const isExplicitPresentational = presentationRoles.has(explicitRole);
  const isPresentational = presentationRoles.has(role);
  const isGeneric = role === "generic";
  const spokenRole = getSpokenRole({
    isGeneric,
    isPresentational,
    node,
    role
  });
  const { allowedChildRoles: allowedAccessibilityChildRoles } = import_html_aria2.roles[role] ?? {
    allowedChildRoles: []
  };
  const { allowedChildRoles: implicitAllowedAccessibilityChildRoles } = import_html_aria2.roles[implicitRole] ?? {
    allowedChildRoles: []
  };
  const isChildrenPresentationalRole = childrenPresentationalRoles.has(role);
  const isExplicitOrInheritedPresentation = isExplicitPresentational || inheritedImplicitPresentational;
  const isElementWithImplicitAllowedAccessibilityChildRoles = !!implicitAllowedAccessibilityChildRoles.length;
  const childrenInheritPresentationExceptAllowedRoles = isExplicitOrInheritedPresentation && isElementWithImplicitAllowedAccessibilityChildRoles;
  const childrenPresentational = isChildrenPresentationalRole || childrenInheritPresentationExceptAllowedRoles;
  const isInert = getIsInert({
    inheritedImplicitInert,
    node,
    role
  });
  return {
    accessibleDescription: amendedAccessibleDescription,
    accessibleName,
    accessibleValue,
    allowedAccessibilityChildRoles,
    childrenPresentational,
    isExplicitPresentational,
    isInert,
    role,
    spokenRole
  };
}

// src/getNodeByIdRef.ts
function getNodeByIdRef({
  container,
  idRef: idRef2
}) {
  if (!isElement(container) || !idRef2) {
    return null;
  }
  return container.querySelector(`#${CSS.escape(idRef2)}`);
}

// src/isHiddenFromAccessibilityTree.ts
var TEXT_NODE = 3;
function isHiddenFromAccessibilityTree(node) {
  if (!node) {
    return true;
  }
  if (node.nodeType === TEXT_NODE && node.textContent.trim()) {
    return false;
  }
  if (!isElement(node)) {
    return true;
  }
  try {
    if (node.hidden === true) {
      return true;
    }
    if (node.getAttribute("aria-hidden") === "true") {
      return true;
    }
    const getComputedStyle = node.ownerDocument.defaultView?.getComputedStyle;
    const computedStyle = getComputedStyle?.(node);
    if (computedStyle?.visibility === "hidden" || computedStyle?.display === "none") {
      return true;
    }
  } catch {
    return true;
  }
  return false;
}

// src/createAccessibilityTree.ts
function addAlternateReadingOrderNodes(node, alternateReadingOrderMap, container) {
  const idRefs2 = getIdRefsByAttribute({
    attributeName: "aria-flowto",
    node
  });
  idRefs2.forEach((idRef2) => {
    const childNode = getNodeByIdRef({ container, idRef: idRef2 });
    if (!childNode) {
      return;
    }
    const currentParentNodes = alternateReadingOrderMap.get(childNode) ?? /* @__PURE__ */ new Set();
    currentParentNodes.add(node);
    alternateReadingOrderMap.set(childNode, currentParentNodes);
  });
}
function mapAlternateReadingOrder(node) {
  const alternateReadingOrderMap = /* @__PURE__ */ new Map();
  if (!isElement(node)) {
    return alternateReadingOrderMap;
  }
  node.querySelectorAll("[aria-flowto]").forEach(
    (parentNode) => addAlternateReadingOrderNodes(parentNode, alternateReadingOrderMap, node)
  );
  return alternateReadingOrderMap;
}
function addOwnedNodes(node, ownedNodes, container) {
  const idRefs2 = getIdRefsByAttribute({
    attributeName: "aria-owns",
    node
  });
  idRefs2.forEach((idRef2) => {
    const ownedNode = getNodeByIdRef({ container, idRef: idRef2 });
    if (!!ownedNode && !ownedNodes.has(ownedNode)) {
      ownedNodes.add(ownedNode);
    }
  });
}
function getAllOwnedNodes(node) {
  const ownedNodes = /* @__PURE__ */ new Set();
  if (!isElement(node)) {
    return ownedNodes;
  }
  node.querySelectorAll("[aria-owns]").forEach((owningNode) => addOwnedNodes(owningNode, ownedNodes, node));
  return ownedNodes;
}
function getOwnedNodes(node, container) {
  const ownedNodes = /* @__PURE__ */ new Set();
  if (!isElement(node) || !isElement(container)) {
    return ownedNodes;
  }
  addOwnedNodes(node, ownedNodes, container);
  return ownedNodes;
}
function growTree(node, tree, {
  alternateReadingOrderMap,
  container,
  ownedNodes,
  visitedNodes
}) {
  if (visitedNodes.has(node)) {
    return tree;
  }
  visitedNodes.add(node);
  const parentDialog = isDialogRole(tree.role) ? tree.node : tree.parentDialog;
  if (parentDialog) {
    tree.parentDialog = parentDialog;
  }
  node.childNodes.forEach((childNode) => {
    if (isHiddenFromAccessibilityTree(childNode)) {
      return;
    }
    if (ownedNodes.has(childNode)) {
      return;
    }
    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode) ? (
      // `alternateReadingOrderMap.has(childNode)` null guards here.
      Array.from(alternateReadingOrderMap.get(childNode))
    ) : [];
    const {
      accessibleDescription,
      accessibleName,
      accessibleValue,
      allowedAccessibilityChildRoles,
      childrenPresentational,
      isExplicitPresentational,
      isInert,
      role,
      spokenRole
    } = getNodeAccessibilityData({
      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,
      inheritedImplicitInert: tree.isInert,
      inheritedImplicitPresentational: tree.childrenPresentational,
      node: childNode
    });
    const childTree = growTree(
      childNode,
      {
        accessibleDescription,
        accessibleName,
        accessibleValue,
        allowedAccessibilityChildRoles,
        alternateReadingOrderParents,
        children: [],
        childrenPresentational,
        isInert,
        node: childNode,
        parentAccessibilityNodeTree: null,
        // Added during flattening
        parent: node,
        parentDialog,
        role,
        spokenRole
      },
      { alternateReadingOrderMap, container, ownedNodes, visitedNodes }
    );
    if (isExplicitPresentational) {
      tree.children.push(...childTree.children);
    } else {
      tree.children.push(childTree);
    }
  });
  const ownedChildNodes = getOwnedNodes(node, container);
  ownedChildNodes.forEach((childNode) => {
    if (isHiddenFromAccessibilityTree(childNode)) {
      return;
    }
    const alternateReadingOrderParents = alternateReadingOrderMap.has(childNode) ? (
      // `alternateReadingOrderMap.has(childNode)` null guards here.
      Array.from(alternateReadingOrderMap.get(childNode))
    ) : [];
    const {
      accessibleDescription,
      accessibleName,
      accessibleValue,
      allowedAccessibilityChildRoles,
      childrenPresentational,
      isInert,
      isExplicitPresentational,
      role,
      spokenRole
    } = getNodeAccessibilityData({
      allowedAccessibilityRoles: tree.allowedAccessibilityChildRoles,
      inheritedImplicitInert: tree.isInert,
      inheritedImplicitPresentational: tree.childrenPresentational,
      node: childNode
    });
    const childTree = growTree(
      childNode,
      {
        accessibleDescription,
        accessibleName,
        accessibleValue,
        allowedAccessibilityChildRoles,
        alternateReadingOrderParents,
        children: [],
        childrenPresentational,
        isInert,
        node: childNode,
        parentAccessibilityNodeTree: null,
        // Added during flattening
        parent: node,
        parentDialog,
        role,
        spokenRole
      },
      { alternateReadingOrderMap, container, ownedNodes, visitedNodes }
    );
    if (isExplicitPresentational) {
      tree.children.push(...childTree.children);
    } else {
      tree.children.push(childTree);
    }
  });
  return tree;
}
function createAccessibilityTree(node) {
  if (isHiddenFromAccessibilityTree(node)) {
    return null;
  }
  const alternateReadingOrderMap = mapAlternateReadingOrder(node);
  const ownedNodes = getAllOwnedNodes(node);
  const visitedNodes = /* @__PURE__ */ new Set();
  const {
    accessibleDescription,
    accessibleName,
    accessibleValue,
    allowedAccessibilityChildRoles,
    childrenPresentational,
    isInert,
    role,
    spokenRole
  } = getNodeAccessibilityData({
    allowedAccessibilityRoles: [],
    node,
    inheritedImplicitPresentational: false,
    inheritedImplicitInert: false
  });
  const tree = growTree(
    node,
    {
      accessibleDescription,
      accessibleName,
      accessibleValue,
      allowedAccessibilityChildRoles,
      alternateReadingOrderParents: [],
      children: [],
      childrenPresentational,
      isInert,
      node,
      parentAccessibilityNodeTree: null,
      parent: null,
      parentDialog: null,
      role,
      spokenRole
    },
    {
      alternateReadingOrderMap,
      container: node,
      ownedNodes,
      visitedNodes
    }
  );
  return tree;
}

// src/commands/nodeMatchers.ts
function matchesRoles(node, roles3) {
  if (!roles3?.length) {
    return true;
  }
  return roles3.includes(node.role);
}
function matchesAccessibleAttributes(node, ariaAttributes) {
  if (!ariaAttributes) {
    return true;
  }
  for (const [name, value] of Object.entries(ariaAttributes)) {
    if (node.accessibleAttributeToLabelMap[name]?.value !== value) {
      return false;
    }
  }
  return true;
}

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getAttributesByRole.ts
var import_html_aria3 = require("html-aria");
var ignoreAttributesWithAccessibleValue = /* @__PURE__ */ new Set(["aria-placeholder"]);
var nonSpecCompliantAttributeMap = {
  listitem: { "aria-level": null },
  option: { "aria-selected": false }
};
var getAttributesByRole = ({
  accessibleValue,
  role
}) => {
  const {
    supported: supportedAttributes = [],
    defaultAttributeValues = {},
    prohibited: prohibitedAttributes = []
  } = import_html_aria3.roles[role] ?? {};
  const implicitRoleAttributes = {
    ...defaultAttributeValues,
    ...nonSpecCompliantAttributeMap[role]
  };
  const uniqueAttributes = Array.from(
    /* @__PURE__ */ new Set([
      ...Object.keys(implicitRoleAttributes),
      ...supportedAttributes,
      ...globalStatesAndProperties
    ])
  ).filter(
    (attribute) => !prohibitedAttributes.includes(attribute)
  ).filter(
    (attribute) => !accessibleValue || !ignoreAttributesWithAccessibleValue.has(attribute)
  );
  return uniqueAttributes.map((attribute) => [
    attribute,
    attribute in implicitRoleAttributes && implicitRoleAttributes[attribute] !== null ? implicitRoleAttributes[attribute].toString() : null
  ]);
};

// src/getItemText.ts
var getItemText = (accessibilityNode) => {
  const { accessibleName, accessibleValue } = accessibilityNode;
  const announcedValue = accessibleName === accessibleValue ? "" : accessibleValue;
  return [accessibleName, announcedValue].filter(Boolean).join(", ");
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/mapAttributeNameAndValueToLabel.ts
var STATE = {
  BUSY: "busy",
  CHECKED: "checked",
  CURRENT: "current item",
  DISABLED: "disabled",
  EXPANDED: "expanded",
  INVALID: "invalid",
  MODAL: "modal",
  MULTI_SELECTABLE: "multi-selectable",
  PARTIALLY_CHECKED: "partially checked",
  PARTIALLY_PRESSED: "partially pressed",
  PRESSED: "pressed",
  READ_ONLY: "read only",
  REQUIRED: "required",
  SELECTED: "selected"
};
var ariaPropertyToVirtualLabelMap = {
  "aria-activedescendant": idRef("active descendant"),
  "aria-atomic": null,
  // Handled by live region logic
  "aria-autocomplete": token({
    inline: "autocomplete inlined",
    list: "autocomplete in list",
    both: "autocomplete inlined and in list",
    none: "no autocomplete"
  }),
  "aria-braillelabel": null,
  // Currently won't do - not implementing a braille screen reader
  "aria-brailleroledescription": null,
  // Currently won't do - not implementing a braille screen reader
  "aria-busy": state(STATE.BUSY),
  "aria-checked": tristate(STATE.CHECKED, STATE.PARTIALLY_CHECKED),
  "aria-colcount": integer("column count"),
  "aria-colindex": integer("column index"),
  "aria-colindextext": string("column index"),
  "aria-colspan": integer("column span"),
  "aria-controls": idRefs("control", "controls"),
  // Handled by virtual.perform()
  "aria-current": token({
    page: "current page",
    step: "current step",
    location: "current location",
    date: "current date",
    time: "current time",
    true: STATE.CURRENT,
    false: `not ${STATE.CURRENT}`
  }),
  "aria-describedby": null,
  // Handled by accessible description
  "aria-description": null,
  // Handled by accessible description
  "aria-details": idRefs("linked details", "linked details", false),
  "aria-disabled": state(STATE.DISABLED),
  "aria-dropeffect": null,
  // Deprecated in WAI-ARIA 1.1
  "aria-errormessage": errorMessageIdRefs("error message", "error messages"),
  "aria-expanded": state(STATE.EXPANDED),
  "aria-flowto": idRefs("alternate reading order", "alternate reading orders"),
  // Handled by virtual.perform()
  "aria-grabbed": null,
  // Deprecated in WAI-ARIA 1.1
  "aria-haspopup": token({
    /**
     * Assistive technologies SHOULD NOT expose the aria-haspopup property if
     * it has a value of false.
     *
     * REF: // https://www.w3.org/TR/wai-aria-1.2/#aria-haspopup
     */
    false: null,
    true: "has popup menu",
    menu: "has popup menu",
    listbox: "has popup listbox",
    tree: "has popup tree",
    grid: "has popup grid",
    dialog: "has popup dialog"
  }),
  "aria-hidden": null,
  // Excluded from accessibility tree
  "aria-invalid": token({
    grammar: "grammatical error detected",
    false: `not ${STATE.INVALID}`,
    spelling: "spelling error detected",
    true: STATE.INVALID
  }),
  "aria-keyshortcuts": string("key shortcuts"),
  "aria-label": null,
  // Handled by accessible name
  "aria-labelledby": null,
  // Handled by accessible name
  "aria-level": integer("level"),
  "aria-live": null,
  // Handled by live region logic
  "aria-modal": state(STATE.MODAL),
  "aria-multiselectable": state(STATE.MULTI_SELECTABLE),
  "aria-orientation": token({
    horizontal: "orientated horizontally",
    vertical: "orientated vertically"
  }),
  "aria-owns": null,
  // Handled by accessibility tree construction
  "aria-placeholder": string("placeholder"),
  "aria-posinset": integer("position"),
  "aria-pressed": tristate(STATE.PRESSED, STATE.PARTIALLY_PRESSED),
  "aria-readonly": state(STATE.READ_ONLY),
  "aria-relevant": null,
  // Handled by live region logic
  "aria-required": state(STATE.REQUIRED),
  "aria-roledescription": null,
  // Handled by accessible description
  "aria-rowcount": integer("row count"),
  "aria-rowindex": integer("row index"),
  "aria-rowindextext": string("row index"),
  "aria-rowspan": integer("row span"),
  "aria-selected": state(STATE.SELECTED),
  "aria-setsize": integer("set size"),
  "aria-sort": token({
    ascending: "sorted in ascending order",
    descending: "sorted in descending order",
    none: "no defined sort order",
    other: "non ascending / descending sort order applied"
  }),
  "aria-valuemax": number("max value"),
  "aria-valuemin": number("min value"),
  "aria-valuenow": number("current value"),
  "aria-valuetext": string("current value")
};
function state(stateValue) {
  return function stateMapper({ attributeValue, negative }) {
    if (negative) {
      return attributeValue !== "false" ? `not ${stateValue}` : stateValue;
    }
    return attributeValue !== "false" ? stateValue : `not ${stateValue}`;
  };
}
function errorMessageIdRefs(propertyDescriptionSuffixSingular, propertyDescriptionSuffixPlural, printCount = true) {
  return function mapper({ attributeValue, container, node }) {
    if (node?.getAttribute("aria-invalid") === "false") {
      return "";
    }
    return idRefs(
      propertyDescriptionSuffixSingular,
      propertyDescriptionSuffixPlural,
      printCount
    )({ attributeValue, container });
  };
}
function idRefs(propertyDescriptionSuffixSingular, propertyDescriptionSuffixPlural, printCount = true) {
  return function mapper({ attributeValue, container }) {
    const idRefsCount = attributeValue.trim().split(" ").filter(
      (idRef2) => !!container && !!getNodeByIdRef({ container, idRef: idRef2 })
    ).length;
    if (idRefsCount === 0) {
      return "";
    }
    return `${printCount ? `${idRefsCount} ` : ""}${idRefsCount === 1 ? propertyDescriptionSuffixSingular : propertyDescriptionSuffixPlural}`;
  };
}
function idRef(propertyName) {
  return function mapper({ attributeValue: idRef2, container }) {
    const node = getNodeByIdRef({ container, idRef: idRef2 });
    if (!node) {
      return "";
    }
    const accessibleName = getAccessibleName(node);
    const accessibleValue = getAccessibleValue(node);
    const itemText = getItemText({ accessibleName, accessibleValue });
    return concat(propertyName)({ attributeValue: itemText, container });
  };
}
function tristate(stateValue, mixedValue) {
  return function stateMapper({ attributeValue }) {
    if (attributeValue === "mixed") {
      return mixedValue;
    }
    return attributeValue !== "false" ? stateValue : `not ${stateValue}`;
  };
}
function token(tokenMap) {
  return function tokenMapper({ attributeValue }) {
    return tokenMap[attributeValue];
  };
}
function concat(propertyName) {
  return function mapper({ attributeValue }) {
    return attributeValue ? `${propertyName} ${attributeValue}` : "";
  };
}
function integer(propertyName) {
  return concat(propertyName);
}
function number(propertyName) {
  return concat(propertyName);
}
function string(propertyName) {
  return concat(propertyName);
}
var mapAttributeNameAndValueToLabel = ({
  attributeName,
  attributeValue,
  container,
  negative = false,
  node
}) => {
  if (typeof attributeValue !== "string") {
    return null;
  }
  const mapper = ariaPropertyToVirtualLabelMap[attributeName];
  return mapper?.({ attributeValue, container, negative, node }) ?? null;
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromAriaAttribute.ts
var getLabelFromAriaAttribute = ({
  attributeName,
  container,
  node
}) => {
  const attributeValue = node.getAttribute(attributeName);
  return {
    label: mapAttributeNameAndValueToLabel({
      attributeName,
      attributeValue,
      container,
      node
    }) ?? "",
    value: attributeValue ?? ""
  };
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromHtmlEquivalentAttribute.ts
var isNotMatchingElement = ({
  elements,
  node
}) => elements.length && !elements.includes(getLocalName(node));
var isNotMatchingProperties = ({
  node,
  properties
}) => properties.length && !properties.some(({ key, value }) => node.getAttribute(key) === value);
var ariaToHTMLAttributeMapping = {
  "aria-autocomplete": [
    { elements: ["form"], name: "autocomplete" },
    { elements: ["input", "select", "textarea"], name: "autocomplete" }
  ],
  "aria-checked": [
    {
      elements: ["input"],
      implicitMissingValue: "false",
      name: "checked",
      properties: [
        { key: "type", value: "checkbox" },
        { key: "type", value: "radio" }
      ]
    },
    {
      value: "mixed",
      name: "indeterminate"
    }
  ],
  "aria-colspan": [{ elements: ["td", "th"], name: "colspan" }],
  "aria-controls": [
    {
      elements: ["input"],
      name: "list"
    }
  ],
  "aria-disabled": [
    {
      elements: ["button", "input", "optgroup", "option", "select", "textarea"],
      name: "disabled"
    },
    {
      // TODO: Form controls within a valid legend child element of a fieldset
      // with a disabled attribute do not become disabled.
      elements: ["fieldset"],
      name: "disabled"
    }
  ],
  // TODO: Set properties on the summary element.
  // REF: https://www.w3.org/TR/html-aam-1.0/#att-open-details
  // "aria-expanded": [{ elements: ["details"], name: "open" }],
  // TODO: Set properties on the dialog element.
  // REF: https://www.w3.org/TR/html-aam-1.0/#att-open-dialog
  // Not announced, indeed it will be hidden from the accessibility tree.
  // "aria-hidden": [{ name: "hidden" }],
  "aria-invalid": [
    // TODO: If the value doesn't match the pattern: aria-invalid="true";
    // Otherwise, aria-invalid="false"
    // REF: https://www.w3.org/TR/html-aam-1.0/#att-pattern
    // { elements: ["input"], name: "pattern" },
    // TODO: aria-invalid="spelling" or grammar
    // REF: https://www.w3.org/TR/html-aam-1.0/#att-spellcheck
    // { elements: ["input"], name: "spellcheck" },
  ],
  "aria-multiselectable": [{ elements: ["select"], name: "multiple" }],
  "aria-placeholder": [
    { elements: ["input", "textarea"], name: "placeholder" }
  ],
  "aria-valuemax": [
    { elements: ["input"], name: "max" },
    { elements: ["meter", "progress"], name: "max" }
  ],
  "aria-valuemin": [
    { elements: ["input"], name: "min" },
    { elements: ["meter", "progress"], name: "min" }
  ],
  "aria-valuenow": [{ elements: ["meter", "progress"], name: "value" }],
  "aria-readonly": [
    { elements: ["input", "textarea"], name: "readonly" },
    { name: "contenteditable", negative: true }
  ],
  "aria-required": [
    { elements: ["input", "select", "textarea"], name: "required" }
  ],
  "aria-rowspan": [{ elements: ["td", "th"], name: "rowspan" }],
  "aria-selected": [{ elements: ["option"], name: "selected" }]
};
var getLabelFromHtmlEquivalentAttribute = ({
  attributeName,
  container,
  node
}) => {
  const htmlAttribute = ariaToHTMLAttributeMapping[attributeName];
  if (!htmlAttribute?.length) {
    return { label: "", value: "" };
  }
  for (const {
    elements = [],
    implicitMissingValue,
    name,
    negative = false,
    properties = [],
    value
  } of htmlAttribute) {
    if (isNotMatchingElement({ elements, node })) {
      continue;
    }
    if (isNotMatchingProperties({ node, properties })) {
      continue;
    }
    const attributeValue = node.hasAttribute(name) ? value ?? node.getAttribute(name) : node.hasAttribute(attributeName) ? null : implicitMissingValue ?? null;
    const label = mapAttributeNameAndValueToLabel({
      attributeName,
      attributeValue,
      container,
      negative,
      node
    });
    if (label) {
      return { label, value: attributeValue ?? "" };
    }
  }
  return { label: "", value: "" };
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue/getLevelFromDocumentStructure.ts
var getLevelFromDocumentStructure = ({
  level = 1,
  role,
  tree
}) => {
  if (!tree) {
    return `${level}`;
  }
  if (tree.role === role) {
    level++;
  }
  const parentTree = tree.parentAccessibilityNodeTree;
  if (!parentTree) {
    return `${level}`;
  }
  return getLevelFromDocumentStructure({
    role,
    tree: parentTree,
    level
  });
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue/getSet.ts
var getFirstNestedChildrenByRole = ({
  role,
  tree
}) => tree.children.flatMap((child) => {
  if (child.role === role) {
    return child;
  }
  return getFirstNestedChildrenByRole({ role, tree: child });
});
var getParentByRole = ({
  role,
  tree
}) => {
  let parentTree = tree;
  while (parentTree.role !== role && parentTree.parentAccessibilityNodeTree) {
    parentTree = parentTree.parentAccessibilityNodeTree;
  }
  return parentTree;
};
var getSiblingsByRoleAndLevel = ({
  role,
  parentRole = role,
  tree
}) => {
  const parentTree = getParentByRole({ role: parentRole, tree });
  return getFirstNestedChildrenByRole({ role, tree: parentTree });
};
var getFormOwnerTree = ({ tree }) => getParentByRole({ role: "form", tree });
var getRadioInputsByName = ({
  name,
  tree
}) => tree.children.flatMap((child) => {
  if (isElement(child.node) && child.node.getAttribute("name") === name) {
    return child;
  }
  return getRadioInputsByName({ name, tree: child });
});
var getRadioGroup = ({
  node,
  tree
}) => {
  if (node.localName !== "input") {
    return getSiblingsByRoleAndLevel({
      role: "radio",
      parentRole: "radiogroup",
      tree
    });
  }
  if (!node.hasAttribute("name")) {
    return [];
  }
  const name = node.getAttribute("name");
  if (!name) {
    return [];
  }
  const formOwnerTree = getFormOwnerTree({ tree });
  return getRadioInputsByName({ name, tree: formOwnerTree });
};
var getChildrenByRole = ({
  role,
  tree
}) => tree.children.filter((child) => child.role === role);
var getSet = ({
  node,
  role,
  tree
}) => {
  if (role === "treeitem") {
    return getSiblingsByRoleAndLevel({ role, tree });
  }
  if (role === "radio") {
    return getRadioGroup({ node, tree });
  }
  return getChildrenByRole({
    role,
    tree
  });
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue/hasTreegridAncestor.ts
var hasTreegridAncestor = (tree) => {
  if (!tree) {
    return false;
  }
  if (tree.role === "treegrid") {
    return true;
  }
  if (!tree.parentAccessibilityNodeTree) {
    return false;
  }
  return hasTreegridAncestor(tree.parentAccessibilityNodeTree);
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/getLabelFromImplicitHtmlElementValue/index.ts
var headingLocalNameToLevelMap = {
  h1: "1",
  h2: "2",
  h3: "3",
  h4: "4",
  h5: "5",
  h6: "6"
};
var getNodeSet = ({
  node,
  role,
  tree
}) => {
  if (!tree) {
    return null;
  }
  if (role === "article") {
    return null;
  }
  if (role === "row" && !hasTreegridAncestor(tree)) {
    return null;
  }
  return getSet({
    node,
    role,
    tree
  });
};
var levelItemRoles = /* @__PURE__ */ new Set(["listitem", "treeitem"]);
var mapHtmlElementAriaToImplicitValue = {
  /**
   * Used in Roles:
   *
   * - heading
   * - listitem
   * - row
   *
   * Inherits into Roles:
   *
   * - treeitem
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#aria-level
   */
  "aria-level": ({ role, tree, node }) => {
    if (role === "heading") {
      const localName = getLocalName(node);
      return headingLocalNameToLevelMap[localName];
    }
    if (role === "row" && hasTreegridAncestor(tree)) {
      return getLevelFromDocumentStructure({
        role,
        tree
      });
    }
    if (levelItemRoles.has(role)) {
      return getLevelFromDocumentStructure({
        role,
        tree
      });
    }
    return "";
  },
  /**
   * Used in Roles:
   *
   * - article
   * - listitem
   * - menuitem
   * - option
   * - radio
   * - row
   * - tab
   *
   * Inherits into Roles:
   *
   * - menuitemcheckbox
   * - menuitemradio
   * - treeitem
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#aria-posinset
   */
  "aria-posinset": ({ node, tree, role }) => {
    const nodeSet = getNodeSet({ node, role, tree });
    if (!nodeSet?.length) {
      return "";
    }
    const index = nodeSet.findIndex((child) => child.node === node);
    return `${index + 1}`;
  },
  /**
   * Used in Roles:
   *
   * - article
   * - listitem
   * - menuitem
   * - option
   * - radio
   * - row
   * - tab
   *
   * Inherits into Roles:
   *
   * - menuitemcheckbox
   * - menuitemradio
   * - treeitem
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#aria-setsize
   */
  "aria-setsize": ({ node, tree, role }) => {
    const nodeSet = getNodeSet({ node, role, tree });
    if (!nodeSet?.length) {
      return "";
    }
    return `${nodeSet.length}`;
  }
};
var getLabelFromImplicitHtmlElementValue = ({
  attributeName,
  container,
  node,
  parentAccessibilityNodeTree,
  role
}) => {
  const implicitValue = mapHtmlElementAriaToImplicitValue[attributeName]?.({
    node,
    tree: parentAccessibilityNodeTree,
    role
  });
  return {
    label: mapAttributeNameAndValueToLabel({
      attributeName,
      attributeValue: implicitValue,
      container,
      node
    }) ?? "",
    value: implicitValue ?? ""
  };
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessAriaValueNow.ts
var percentageBasedValueRoles = /* @__PURE__ */ new Set(["progressbar", "scrollbar"]);
var isNumberLike = (value) => {
  return !isNaN(parseFloat(value));
};
var toNumber = (value) => parseFloat(value);
var toPercentageLabel = (value) => `current value ${value}%`;
var postProcessAriaValueNow = ({
  max,
  min,
  role,
  value
}) => {
  if (!percentageBasedValueRoles.has(role)) {
    return value;
  }
  if (!isNumberLike(value)) {
    return value;
  }
  if (isNumberLike(max) && isNumberLike(min)) {
    const percentage = +((toNumber(value) - toNumber(min)) / (toNumber(max) - toNumber(min)) * 100).toFixed(2);
    return toPercentageLabel(percentage);
  }
  return toPercentageLabel(value);
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/postProcessLabels.ts
var priorityReplacementMap = [
  ["aria-colindextext", "aria-colindex"],
  ["aria-rowindextext", "aria-rowindex"],
  /**
   * If aria-valuetext is specified, assistive technologies SHOULD render that
   * value instead of the value of aria-valuenow.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#aria-valuetext
   */
  ["aria-valuetext", "aria-valuenow"]
];
var postProcessLabels = ({
  labels,
  role
}) => {
  for (const [preferred, dropped] of priorityReplacementMap) {
    if (labels[preferred] && labels[dropped]) {
      labels[dropped].value = "";
    }
  }
  if (labels["aria-valuenow"]) {
    labels["aria-valuenow"].label = postProcessAriaValueNow({
      value: labels["aria-valuenow"].value,
      min: labels["aria-valuemin"]?.value,
      max: labels["aria-valuemax"]?.value,
      role
    });
  }
  if (labels["aria-setsize"]?.value === "-1") {
    labels["aria-setsize"].label = "set size unknown";
  }
  return labels;
};

// src/getNodeAccessibilityData/getAccessibleAttributeLabels/index.ts
var getAccessibleAttributeLabels = ({
  accessibleValue,
  alternateReadingOrderParents,
  container,
  node,
  parentAccessibilityNodeTree,
  role
}) => {
  if (!isElement(node)) {
    return {
      accessibleAttributeLabels: [],
      accessibleAttributeToLabelMap: {}
    };
  }
  const labels = {};
  const attributes = getAttributesByRole({ accessibleValue, role });
  attributes.forEach(([attributeName, implicitAttributeValue]) => {
    const {
      label: labelFromHtmlEquivalentAttribute,
      value: valueFromHtmlEquivalentAttribute
    } = getLabelFromHtmlEquivalentAttribute({
      attributeName,
      container,
      node
    });
    if (labelFromHtmlEquivalentAttribute) {
      labels[attributeName] = {
        label: labelFromHtmlEquivalentAttribute,
        value: valueFromHtmlEquivalentAttribute
      };
      return;
    }
    const { label: labelFromAriaAttribute, value: valueFromAriaAttribute } = getLabelFromAriaAttribute({
      attributeName,
      container,
      node
    });
    if (labelFromAriaAttribute) {
      labels[attributeName] = {
        label: labelFromAriaAttribute,
        value: valueFromAriaAttribute
      };
      return;
    }
    const {
      label: labelFromImplicitHtmlElementValue,
      value: valueFromImplicitHtmlElementValue
    } = getLabelFromImplicitHtmlElementValue({
      attributeName,
      container,
      node,
      parentAccessibilityNodeTree,
      role
    });
    if (labelFromImplicitHtmlElementValue) {
      labels[attributeName] = {
        label: labelFromImplicitHtmlElementValue,
        value: valueFromImplicitHtmlElementValue
      };
      return;
    }
    const labelFromImplicitAriaAttributeValue = mapAttributeNameAndValueToLabel(
      {
        attributeName,
        attributeValue: implicitAttributeValue,
        container,
        node
      }
    );
    if (labelFromImplicitAriaAttributeValue) {
      labels[attributeName] = {
        label: labelFromImplicitAriaAttributeValue,
        value: implicitAttributeValue ?? ""
      };
      return;
    }
  });
  const accessibleAttributeToLabelMap = postProcessLabels({ labels, role });
  const accessibleAttributeLabels = Object.values(accessibleAttributeToLabelMap).map(({ label }) => label).filter(Boolean);
  if (alternateReadingOrderParents.length > 0) {
    accessibleAttributeLabels.push(
      `${alternateReadingOrderParents.length} previous alternate reading ${alternateReadingOrderParents.length === 1 ? "order" : "orders"}`
    );
  }
  return { accessibleAttributeLabels, accessibleAttributeToLabelMap };
};

// src/flattenTree.ts
var END_OF_ROLE_PREFIX = "end of";
var END_OF_NO_ROLE_PREFIX = "end";
var TEXT_NODE2 = 3;
function shouldIgnoreChildren(tree) {
  const { accessibleName, children, node } = tree;
  if (!accessibleName) {
    return false;
  }
  if (children.length > 1) {
    return false;
  }
  if (children.every((child) => child.node.nodeType !== TEXT_NODE2)) {
    return false;
  }
  return accessibleName === (node.textContent || `${node.value}` || "")?.trim();
}
function flattenTree(container, tree, parentAccessibilityNodeTree) {
  const { children, ...treeNode } = tree;
  treeNode.parentAccessibilityNodeTree = parentAccessibilityNodeTree;
  const { accessibleAttributeLabels, accessibleAttributeToLabelMap } = getAccessibleAttributeLabels({
    ...treeNode,
    container
  });
  const treeNodeWithAttributeLabels = {
    ...treeNode,
    accessibleAttributeLabels,
    accessibleAttributeToLabelMap
  };
  const isAnnounced = !treeNodeWithAttributeLabels.isInert && (!!treeNodeWithAttributeLabels.accessibleName || !!treeNodeWithAttributeLabels.accessibleDescription || treeNodeWithAttributeLabels.accessibleAttributeLabels.length > 0 || !!treeNodeWithAttributeLabels.spokenRole);
  const ignoreChildren = shouldIgnoreChildren(tree);
  const flattenedTree = ignoreChildren ? [] : children.flatMap(
    (child) => flattenTree(container, child, {
      ...treeNodeWithAttributeLabels,
      children
    })
  );
  const isRoleContainer = !!flattenedTree.length && !ignoreChildren && isAnnounced;
  if (isAnnounced) {
    flattenedTree.unshift(treeNodeWithAttributeLabels);
  }
  if (isRoleContainer) {
    flattenedTree.push({
      ...treeNodeWithAttributeLabels,
      spokenRole: treeNodeWithAttributeLabels.spokenRole ? `${END_OF_ROLE_PREFIX} ${treeNodeWithAttributeLabels.spokenRole}` : END_OF_NO_ROLE_PREFIX
    });
  }
  return flattenedTree;
}

// src/commands/getIndexByRoleAndAttributes.ts
function getIndexByRoleAndAttributes({
  filters,
  reorderedTree,
  tree
}) {
  const accessibilityNode = reorderedTree.find(
    (node) => !node.spokenRole.startsWith(END_OF_ROLE_PREFIX) && matchesRoles(node, filters.roles) && matchesAccessibleAttributes(node, filters.ariaAttributes)
  );
  if (!accessibilityNode) {
    return null;
  }
  return tree.findIndex((node) => node === accessibilityNode);
}

// src/commands/getNextIndexByRoleAndAttributes.ts
function getNextIndexByRoleAndAttributes(filters) {
  return function getNextIndexByRoleAndAttributesInner({
    currentIndex,
    tree
  }) {
    const reorderedTree = tree.slice(currentIndex + 1).concat(tree.slice(0, currentIndex + 1));
    return getIndexByRoleAndAttributes({ filters, reorderedTree, tree });
  };
}

// src/commands/getPreviousIndexByRoleAndAttributes.ts
function getPreviousIndexByRoleAndAttributes(filters) {
  return function getPreviousIndexInner({
    currentIndex,
    tree
  }) {
    const reorderedTree = tree.slice(0, currentIndex).reverse().concat(tree.slice(currentIndex).reverse());
    return getIndexByRoleAndAttributes({ filters, reorderedTree, tree });
  };
}

// src/getElementFromNode.ts
var getElementFromNode = (node) => {
  return isElement(node) ? node : node.parentElement;
};

// src/commands/getElementNode.ts
function getElementNode(accessibilityNode) {
  const { node } = accessibilityNode;
  return getElementFromNode(node);
}

// src/commands/getNextIndexByIdRefsAttribute.ts
function getNextIndexByIdRefsAttribute({
  attributeName,
  index = 0,
  container,
  currentIndex,
  tree
}) {
  if (!isElement(container)) {
    return;
  }
  const currentAccessibilityNode = tree.at(currentIndex);
  const currentNode = getElementNode(currentAccessibilityNode);
  const idRefs2 = getIdRefsByAttribute({
    attributeName,
    node: currentNode
  });
  const idRef2 = idRefs2[index];
  const targetNode = getNodeByIdRef({ container, idRef: idRef2 });
  if (!targetNode) {
    return;
  }
  const nodeIndex = tree.findIndex(({ node }) => node === targetNode);
  if (nodeIndex !== -1) {
    return nodeIndex;
  }
  const nodeIndexByParent = tree.findIndex(
    ({ parent }) => parent === targetNode
  );
  if (nodeIndexByParent !== -1) {
    return nodeIndexByParent;
  }
  return;
}

// src/commands/jumpToControlledElement.ts
function jumpToControlledElement({
  index = 0,
  container,
  currentIndex,
  tree
}) {
  return getNextIndexByIdRefsAttribute({
    attributeName: "aria-controls",
    index,
    container,
    currentIndex,
    tree
  });
}

// src/commands/jumpToDetailsElement.ts
function jumpToDetailsElement({
  container,
  currentIndex,
  tree
}) {
  return getNextIndexByIdRefsAttribute({
    attributeName: "aria-details",
    index: 0,
    container,
    currentIndex,
    tree
  });
}

// src/commands/jumpToErrorMessageElement.ts
function jumpToErrorMessageElement({
  index = 0,
  container,
  currentIndex,
  tree
}) {
  return getNextIndexByIdRefsAttribute({
    attributeName: "aria-errormessage",
    index,
    container,
    currentIndex,
    tree
  });
}

// src/commands/moveToNextAlternateReadingOrderElement.ts
function moveToNextAlternateReadingOrderElement({
  index,
  container,
  currentIndex,
  tree
}) {
  return getNextIndexByIdRefsAttribute({
    attributeName: "aria-flowto",
    index,
    container,
    currentIndex,
    tree
  });
}

// src/commands/moveToPreviousAlternateReadingOrderElement.ts
function moveToPreviousAlternateReadingOrderElement({
  index = 0,
  container,
  currentIndex,
  tree
}) {
  if (!isElement(container)) {
    return;
  }
  const { alternateReadingOrderParents } = tree.at(currentIndex);
  const targetNode = alternateReadingOrderParents[index];
  if (!targetNode) {
    return;
  }
  return tree.findIndex(({ node }) => node === targetNode);
}

// src/commands/index.ts
var quickLandmarkNavigationRoles = [
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role banner.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#banner
   */
  "banner",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role complementary.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#complementary
   */
  "complementary",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role contentinfo.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#contentinfo
   */
  "contentinfo",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * figures.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#figure
   */
  "figure",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role form.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#form
   */
  "form",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role main.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#main
   */
  "main",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role navigation.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#navigation
   */
  "navigation",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role region.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#region
   */
  "region",
  /**
   * Assistive technologies SHOULD enable users to quickly navigate to
   * elements with role search.
   *
   * REF: https://www.w3.org/TR/wai-aria-1.2/#search
   */
  "search"
];
var quickAriaRoleNavigationRoles = [
  ...quickLandmarkNavigationRoles,
  /**
   * WAI-ARIA doesn't specify that assistive technologies should enable users
   * to quickly navigate to elements with role heading. However, it is very
   * common for assistive technology users to navigate between headings.
   *
   * REF:
   * - https://www.w3.org/TR/wai-aria-1.2/#heading
   * - https://webaim.org/projects/screenreadersurvey10/#heading
   * - https://webaim.org/projects/screenreadersurvey10/#finding
   *
   * MUST requirements:
   *
   * Headings provide an outline of the page and users need to be able to
   * quickly navigate to different sections of the page.
   *
   * REF: https://a11ysupport.io/tech/aria/heading_role
   */
  "heading",
  /**
   * WAI-ARIA doesn't specify that assistive technologies should enable users
   * to quickly navigate to elements with role link. However, it is very
   * common for assistive technology users to navigate between links.
   *
   * REF:
   * - https://www.w3.org/TR/wai-aria-1.2/#link
   * - https://webaim.org/projects/screenreadersurvey10/#finding
   */
  "link"
];
var quickAriaRoleNavigationCommands = quickAriaRoleNavigationRoles.reduce(
  (accumulatedCommands, role) => {
    const moveToNextCommand = `moveToNext${role.at(0).toUpperCase()}${role.slice(1)}`;
    const moveToPreviousCommand = `moveToPrevious${role.at(0).toUpperCase()}${role.slice(1)}`;
    return {
      ...accumulatedCommands,
      [moveToNextCommand]: getNextIndexByRoleAndAttributes({ roles: [role] }),
      [moveToPreviousCommand]: getPreviousIndexByRoleAndAttributes({
        roles: [role]
      })
    };
  },
  {}
);
var headingLevels = ["1", "2", "3", "4", "5", "6"];
var headingLevelNavigationCommands = headingLevels.reduce((accumulatedCommands, headingLevel) => {
  const moveToNextCommand = `moveToNextHeadingLevel${headingLevel}`;
  const moveToPreviousCommand = `moveToPreviousHeadingLevel${headingLevel}`;
  return {
    ...accumulatedCommands,
    [moveToNextCommand]: getNextIndexByRoleAndAttributes({
      ariaAttributes: { "aria-level": headingLevel }
    }),
    [moveToPreviousCommand]: getPreviousIndexByRoleAndAttributes({
      ariaAttributes: { "aria-level": headingLevel }
    })
  };
}, {});
var commands = {
  /**
   * Jump to an element controlled by the current element in the Virtual Screen
   * Reader focus. See [aria-controls](https://www.w3.org/TR/wai-aria-1.2/#aria-controls).
   *
   * When using with `virtual.perform()`, pass an index option to select which
   * controlled element is jumped to when there are more than one:
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to jump to the second controlled element.
   *   await virtual.perform(virtual.commands.jumpToControlledElement, { index: 1 });
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  jumpToControlledElement,
  /**
   * Jump to an element that describes the current element in the Virtual
   * Screen Reader focus. See [aria-details](https://www.w3.org/TR/wai-aria-1.2/#aria-details).
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to jump to the details element.
   *   await virtual.perform(virtual.commands.jumpToDetailsElement);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  jumpToDetailsElement,
  /**
   * Jump to an element that provides an error message for the current element
   * in the Virtual Screen Reader focus. See [aria-errormessage](https://www.w3.org/TR/wai-aria-1.2/#aria-errormessage).
   *
   * When using with `virtual.perform()`, pass an `index` option to select
   * which error message element is jumped to when there are more than one:
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to jump to the second error message element.
   *   await virtual.perform(virtual.commands.jumpToErrorMessageElement, {
   *     index: 1,
   *   });
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  jumpToErrorMessageElement,
  /**
   * Move to the next element in an alternate reading order. See
   * [aria-flowto](https://www.w3.org/TR/wai-aria-1.2/#aria-flowto).
   *
   * When using with `virtual.perform()`, pass an `index` option to select
   * which alternate reading order element is jumped to when there are more
   * than one:
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the second choice element of next alternate reading order.
   *   await virtual.perform(
   *     virtual.commands.moveToNextAlternateReadingOrderElement,
   *     { index: 1 }
   *   );
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  moveToNextAlternateReadingOrderElement,
  /**
   * Move to the previous element in an alternate reading order. See
   * [aria-flowto](https://www.w3.org/TR/wai-aria-1.2/#aria-flowto).
   *
   * When using with `virtual.perform()`, pass an `index` option to select
   * which alternate reading order element is jumped to when there are more than
   * one:
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the second choice element of previous alternate reading order.
   *   await virtual.perform(
   *     virtual.commands.moveToPreviousAlternateReadingOrderElement,
   *     { index: 1 }
   *   );
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  moveToPreviousAlternateReadingOrderElement,
  ...quickAriaRoleNavigationCommands,
  /**
   * Move to the next element with any [`landmark`](https://www.w3.org/TR/wai-aria-1.2/#landmark)
   * role:
   *
   * - [`banner`](https://www.w3.org/TR/wai-aria-1.2/#banner)
   * - [`complementary`](https://www.w3.org/TR/wai-aria-1.2/#complementary)
   * - [`contentinfo`](https://www.w3.org/TR/wai-aria-1.2/#contentinfo)
   * - [`figure`](https://www.w3.org/TR/wai-aria-1.2/#figure)
   * - [`form`](https://www.w3.org/TR/wai-aria-1.2/#form)
   * - [`landmark`](https://www.w3.org/TR/wai-aria-1.2/#landmark)
   * - [`main`](https://www.w3.org/TR/wai-aria-1.2/#main)
   * - [`navigation`](https://www.w3.org/TR/wai-aria-1.2/#navigation)
   * - [`region`](https://www.w3.org/TR/wai-aria-1.2/#region)
   * - [`search`](https://www.w3.org/TR/wai-aria-1.2/#search)
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the next landmark element.
   *   await virtual.perform(virtual.commands.moveToNextLandmark);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  moveToNextLandmark: getNextIndexByRoleAndAttributes({
    roles: quickLandmarkNavigationRoles
  }),
  /**
   * Move to the previous element with any [`landmark`](https://www.w3.org/TR/wai-aria-1.2/#landmark)
   * role:
   *
   * - [`banner`](https://www.w3.org/TR/wai-aria-1.2/#banner)
   * - [`complementary`](https://www.w3.org/TR/wai-aria-1.2/#complementary)
   * - [`contentinfo`](https://www.w3.org/TR/wai-aria-1.2/#contentinfo)
   * - [`figure`](https://www.w3.org/TR/wai-aria-1.2/#figure)
   * - [`form`](https://www.w3.org/TR/wai-aria-1.2/#form)
   * - [`landmark`](https://www.w3.org/TR/wai-aria-1.2/#landmark)
   * - [`main`](https://www.w3.org/TR/wai-aria-1.2/#main)
   * - [`navigation`](https://www.w3.org/TR/wai-aria-1.2/#navigation)
   * - [`region`](https://www.w3.org/TR/wai-aria-1.2/#region)
   * - [`search`](https://www.w3.org/TR/wai-aria-1.2/#search)
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the previous landmark element.
   *   await virtual.perform(virtual.commands.moveToPreviousLandmark);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  moveToPreviousLandmark: getPreviousIndexByRoleAndAttributes({
    roles: quickLandmarkNavigationRoles
  }),
  ...headingLevelNavigationCommands
};

// src/errors.ts
var ERR_VIRTUAL_MISSING_CONTAINER = "A container was not provided";
var ERR_VIRTUAL_NOT_STARTED = "Virtual Screen Reader was not started";

// src/getLiveSpokenPhrase.ts
var LIVE = {
  ASSERTIVE: "assertive",
  OFF: "off",
  POLITE: "polite"
};
var RELEVANT = {
  ADDITIONS: "additions",
  ALL: "all",
  REMOVALS: "removals",
  TEXT: "text"
};
var RELEVANT_VALUES = new Set(Object.values(RELEVANT));
var DEFAULT_ATOMIC = false;
var DEFAULT_LIVE = LIVE.OFF;
var DEFAULT_RELEVANT = [RELEVANT.ADDITIONS, RELEVANT.TEXT];
function getSpokenPhraseForNode(node) {
  return getAccessibleName(node) || getAccessibleValue(node) || // `node.textContent` is only `null` if the `node` is a `document` or a
  // `doctype`. We don't consider either.
  sanitizeString(node.textContent);
}
function getAllSpokenPhrase({
  addedNodes,
  removedNodes,
  target,
  type
}) {
  return [
    ...getAdditionsSpokenPhrase({
      addedNodes
    }),
    ...getRemovalsSpokenPhrase({
      removedNodes
    }),
    ...getTextSpokenPhrase({
      addedNodes,
      target,
      type
    })
  ];
}
function getAdditionsSpokenPhrase({ addedNodes }) {
  return Array.from(addedNodes).filter(isElement).map(getSpokenPhraseForNode);
}
function getRemovalsSpokenPhrase({ removedNodes }) {
  return Array.from(removedNodes).map(
    (removedNode) => `removal: ${getSpokenPhraseForNode(removedNode)}`
  );
}
var TEXT_NODE3 = 3;
function getTextSpokenPhrase({
  addedNodes,
  target,
  type
}) {
  switch (type) {
    case "childList": {
      if (!addedNodes.length) {
        break;
      }
      return Array.from(addedNodes).filter((node) => node.nodeType === TEXT_NODE3).map(getSpokenPhraseForNode);
    }
    case "characterData": {
      return [getSpokenPhraseForNode(target)];
    }
  }
  return [];
}
var relevantToSpokenPhraseMap = {
  [RELEVANT.ADDITIONS]: getAdditionsSpokenPhrase,
  [RELEVANT.ALL]: getAllSpokenPhrase,
  [RELEVANT.REMOVALS]: getRemovalsSpokenPhrase,
  [RELEVANT.TEXT]: getTextSpokenPhrase
};
var roleToImplicitLiveRegionStatesAndPropertiesMap = {
  alert: {
    atomic: true,
    live: LIVE.ASSERTIVE
  },
  log: {
    live: LIVE.POLITE
  },
  marquee: {
    live: LIVE.OFF
  },
  status: {
    atomic: true,
    live: LIVE.POLITE
  },
  timer: {
    live: LIVE.OFF
  },
  alertdialog: {
    atomic: true,
    live: LIVE.ASSERTIVE
  }
};
function getLiveRegionAttributes({
  container,
  target
}, {
  atomic,
  live,
  liveTarget,
  relevant
} = {}) {
  const accessibleName = getAccessibleName(target);
  const { role } = getRole({
    accessibleName,
    allowedAccessibilityRoles: [],
    inheritedImplicitPresentational: false,
    node: target
  });
  const implicitAttributes = roleToImplicitLiveRegionStatesAndPropertiesMap[role];
  if (typeof atomic === "undefined" && target.hasAttribute("aria-atomic")) {
    atomic = target.getAttribute("aria-atomic") === "true";
  }
  if (typeof live === "undefined" && target.hasAttribute("aria-live")) {
    live = target.getAttribute("aria-live");
    liveTarget = target;
  }
  if (typeof live === "undefined" && implicitAttributes) {
    live = implicitAttributes.live;
    liveTarget = target;
    if (typeof atomic === "undefined") {
      atomic = implicitAttributes.atomic;
    }
  }
  if (typeof relevant === "undefined" && target.hasAttribute("aria-relevant")) {
    relevant = target.getAttribute("aria-relevant").split(" ").filter(
      (token2) => !!RELEVANT_VALUES.has(token2)
    );
    if (relevant.includes(RELEVANT.ALL)) {
      relevant = [RELEVANT.ALL];
    }
  }
  if (typeof atomic !== "undefined" && typeof live !== "undefined" && typeof relevant !== "undefined") {
    return {
      atomic,
      live,
      liveTarget,
      relevant
    };
  }
  const targetAncestor = target.parentElement;
  if (target === container || targetAncestor === null) {
    return {
      atomic: atomic ?? DEFAULT_ATOMIC,
      live: live ?? DEFAULT_LIVE,
      liveTarget,
      relevant: relevant ?? DEFAULT_RELEVANT
    };
  }
  return getLiveRegionAttributes(
    { container, target: targetAncestor },
    {
      atomic,
      live,
      liveTarget,
      relevant
    }
  );
}
function getLiveSpokenPhrase({
  container,
  mutation: { addedNodes, removedNodes, target, type }
}) {
  const { atomic, live, liveTarget, relevant } = getLiveRegionAttributes({
    container,
    target: getElementFromNode(target)
  });
  if (live === LIVE.OFF || !liveTarget) {
    return "";
  }
  if (atomic) {
    return `${live}: ${getSpokenPhraseForNode(liveTarget)}`;
  }
  const spokenPhrases = relevant.flatMap(
    (relevantType) => relevantToSpokenPhraseMap[relevantType]({
      addedNodes,
      removedNodes,
      target,
      type
    })
  ).filter(Boolean).join(", ");
  if (!spokenPhrases) {
    return "";
  }
  return `${live}: ${spokenPhrases}`;
}

// src/getSpokenPhrase.ts
var getSpokenPhrase = (accessibilityNode) => {
  const {
    accessibleAttributeLabels,
    accessibleDescription,
    accessibleName,
    accessibleValue,
    spokenRole
  } = accessibilityNode;
  const announcedValue = accessibleName === accessibleValue ? "" : accessibleValue;
  return [
    spokenRole,
    accessibleName,
    announcedValue,
    accessibleDescription,
    ...accessibleAttributeLabels
  ].filter(Boolean).join(", ");
};

// src/observeDOM.ts
function observeDOM(root, node, onChange) {
  if (!isElement(node)) {
    return () => {
    };
  }
  const MutationObserver = typeof root !== "undefined" ? root?.MutationObserver : null;
  if (MutationObserver) {
    const mutationObserver = new MutationObserver(onChange);
    mutationObserver.observe(node, {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true
    });
    return () => {
      mutationObserver.disconnect();
    };
  }
  return () => {
  };
}

// src/tick.ts
async function tick() {
  return await new Promise((resolve) => setTimeout(() => resolve()));
}

// src/Virtual.ts
var import_user_event = require("@testing-library/user-event");
var MacOSModifiers = {
  /**
   * The Command (alias cmd, ⌘) key.
   */
  Command: "command",
  CommandLeft: "command",
  CommandRight: "command",
  Meta: "command",
  /**
   * The Control (alias ctrl, ⌃) key.
   */
  Control: "control",
  ControlLeft: "control",
  ControlRight: "control",
  /**
   * The Option (alias alt, ⌥) key.
   */
  Option: "option",
  OptionLeft: "option",
  OptionRight: "option",
  Alt: "option",
  AltLeft: "option",
  AltRight: "option",
  /**
   * The Shift (alias ⇧) key.
   */
  Shift: "shift",
  ShiftLeft: "shift",
  ShiftRight: "shift"
};
var WindowsModifiers = {
  /**
   * Hold down the Control (alias ctrl, ⌃) key.
   */
  Control: "control",
  /**
   * Hold down the Alt (alias ⎇) key.
   */
  Alt: "alt",
  /**
   * Hold down the Shift (alias ⇧) key.
   */
  Shift: "shift"
};
var defaultUserEventOptions = {
  delay: 0,
  skipHover: true
};
var Virtual = class {
  #activeNode = null;
  #container = null;
  #cursor = null;
  #itemTextLog = [];
  #spokenPhraseLog = [];
  #treeCache = null;
  #disconnectDOMObserver = null;
  #boundHandleFocusChange = null;
  #checkContainer() {
    if (!this.#container) {
      throw new Error(ERR_VIRTUAL_NOT_STARTED);
    }
  }
  #createCursor(root) {
    if (!root?.document) {
      return;
    }
    this.#cursor = root.document.createElement("div");
    this.#cursor.ariaHidden = "true";
    this.#cursor.style.border = "2px dashed #1f1f1f";
    this.#cursor.style.outline = "2px dashed #f0f0f0";
    this.#cursor.style.minHeight = "4px";
    this.#cursor.style.minWidth = "4px";
    this.#cursor.style.position = "absolute";
    this.#cursor.style.left = "0px";
    this.#cursor.style.top = "0px";
    this.#cursor.style.margin = "0px";
    this.#cursor.style.padding = "2px";
    this.#cursor.style.pointerEvents = "none";
    this.#cursor.style.zIndex = "calc(Infinity)";
    this.#cursor.dataset.testid = "virtual-screen-reader-cursor";
    this.#container.appendChild(this.#cursor);
  }
  #setActiveNode(accessibilityNode) {
    this.#activeNode = accessibilityNode;
    if (!this.#cursor) {
      return;
    }
    const rect = getElementNode(accessibilityNode).getBoundingClientRect();
    this.#cursor.style.top = `${rect.top - 2}px`;
    this.#cursor.style.left = `${rect.left - 4}px`;
    this.#cursor.style.width = `${rect.width}px`;
    this.#cursor.style.height = `${rect.height}px`;
  }
  #getAccessibilityTree() {
    if (!this.#treeCache) {
      const tree = createAccessibilityTree(this.#container);
      this.#treeCache = this.#container && tree ? flattenTree(this.#container, tree, null) : [];
    }
    return this.#treeCache;
  }
  #getModalAccessibilityTree() {
    const tree = this.#getAccessibilityTree();
    if (!this.#activeNode) {
      return tree;
    }
    const isModal = this.#activeNode.parentDialog?.getAttribute("aria-modal") === "true";
    if (!isModal) {
      return tree;
    }
    return tree.filter(
      ({ parentDialog }) => this.#activeNode.parentDialog === parentDialog
    );
  }
  #invalidateTreeCache() {
    this.#treeCache = null;
  }
  async #handleFocusChange({ target }) {
    await tick();
    this.#invalidateTreeCache();
    const tree = this.#getAccessibilityTree();
    if (!tree.length) {
      return;
    }
    const newActiveNode = tree.find(({ node }) => node === target);
    if (!newActiveNode) {
      return;
    }
    this.#updateState(newActiveNode, true);
  }
  #focusActiveElement() {
    const target = getElementNode(this.#activeNode);
    target?.focus();
  }
  async #announceLiveRegions(mutations) {
    await tick();
    const container = this.#container;
    mutations.map(
      (mutation) => getLiveSpokenPhrase({
        container,
        mutation
      })
    ).filter(Boolean).forEach((spokenPhrase) => {
      this.#spokenPhraseLog.push(spokenPhrase);
    });
  }
  #spokenPhraseLogWithoutLiveRegions() {
    return this.#spokenPhraseLog.filter(
      (spokenPhrase) => !spokenPhrase.startsWith(LIVE.ASSERTIVE) && !spokenPhrase.startsWith(LIVE.POLITE)
    );
  }
  #updateState(accessibilityNode, ignoreIfNoChange = false) {
    if (accessibilityNode.parentDialog !== null && accessibilityNode.parentDialog !== this.#activeNode?.parentDialog) {
      const tree = this.#getAccessibilityTree();
      const parentDialogNode = tree.find(
        ({ node }) => node === accessibilityNode.parentDialog
      );
      const spokenPhrase2 = getSpokenPhrase(parentDialogNode);
      const itemText2 = getItemText(parentDialogNode);
      this.#itemTextLog.push(itemText2);
      this.#spokenPhraseLog.push(spokenPhrase2);
    }
    this.#setActiveNode(accessibilityNode);
    const spokenPhrase = getSpokenPhrase(accessibilityNode);
    const itemText = getItemText(accessibilityNode);
    if (ignoreIfNoChange && spokenPhrase === this.#spokenPhraseLogWithoutLiveRegions().at(-1) && itemText === this.#itemTextLog.at(-1)) {
      return;
    }
    this.#itemTextLog.push(itemText);
    this.#spokenPhraseLog.push(spokenPhrase);
  }
  async #refreshState(ignoreIfNoChange) {
    await tick();
    this.#invalidateTreeCache();
    const tree = this.#getAccessibilityTree();
    const currentIndex = this.#getCurrentIndexByNode(tree);
    const newActiveNode = tree.at(currentIndex);
    this.#updateState(newActiveNode, ignoreIfNoChange);
  }
  #getCurrentIndex(tree) {
    return tree.findIndex(
      ({
        accessibleDescription,
        accessibleName,
        accessibleValue,
        node,
        role,
        spokenRole
      }) => accessibleDescription === this.#activeNode?.accessibleDescription && accessibleName === this.#activeNode?.accessibleName && accessibleValue === this.#activeNode?.accessibleValue && node === this.#activeNode?.node && role === this.#activeNode?.role && spokenRole === this.#activeNode?.spokenRole
    );
  }
  #getCurrentIndexByNode(tree) {
    return tree.findIndex(({ node }) => node === this.#activeNode?.node);
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-active-node)
   *
   * Getter for the active node under the Virtual Screen Reader cursor.
   *
   * Note that this is not always the same as the currently focused node.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the next element.
   *   await virtual.next();
   *
   *   // Log the currently focused node.
   *   console.log(virtual.activeNode);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @returns {Node|null}
   */
  get activeNode() {
    return this.#activeNode?.node ?? null;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-commands)
   *
   * Getter for all Virtual Screen Reader commands.
   *
   * Use with the `await virtual.perform(command)` command to invoke an action:
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the next landmark.
   *   await virtual.perform(virtual.commands.moveToNextLandmark);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  get commands() {
    return Object.fromEntries(
      Object.keys(commands).map(
        (command) => [command, command]
      )
    );
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-detect)
   *
   * Detect whether the screen reader is supported for the current OS:
   *
   * - `true` for all OS
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   const isVirtualSupportedScreenReader = await virtual.detect();
   *
   *   console.log(isVirtualSupportedScreenReader);
   * });
   * ```
   *
   * @returns {Promise<boolean>}
   */
  async detect() {
    return true;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-default)
   *
   * Detect whether the screen reader is the default screen reader for the current OS.
   *
   * - `false` for all OS
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   const isVirtualDefaultScreenReader = await virtual.default();
   *
   *   console.log(isVirtualDefaultScreenReader);
   * });
   * ```
   *
   * @returns {Promise<boolean>}
   */
  async default() {
    return false;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-start)
   *
   * Turn the Virtual Screen Reader on.
   *
   * This must be called before any other Virtual command can be issued.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader on the entire page.
   *   await virtual.start({ container: document.body });
   *
   *   // ... perform some commands.
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @param {object} [options] Additional options.
   */
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore for non-TS users we default the container to `null` which
  // prompts the missing container error.
  async start({ container, displayCursor = false, window: root } = {
    container: null,
    displayCursor: false
  }) {
    if (!container) {
      throw new Error(ERR_VIRTUAL_MISSING_CONTAINER);
    }
    if (!root && typeof window !== "undefined") {
      root = window;
    }
    this.#container = container;
    if (displayCursor) {
      this.#createCursor(root);
    }
    this.#disconnectDOMObserver = observeDOM(
      root,
      container,
      (mutations) => {
        this.#invalidateTreeCache();
        this.#announceLiveRegions(mutations);
      }
    );
    const tree = this.#getAccessibilityTree();
    if (!tree.length) {
      return;
    }
    this.#boundHandleFocusChange = this.#handleFocusChange.bind(this);
    this.#container.addEventListener("focusin", this.#boundHandleFocusChange);
    this.#updateState(tree[0]);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-stop)
   *
   * Turn the Virtual Screen Reader off.
   *
   * Calling this method will clear any item text or spoken phrases collected by Virtual.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // ... perform some commands.
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async stop() {
    this.#disconnectDOMObserver?.();
    this.#container?.removeEventListener("focusin", this.#boundHandleFocusChange);
    this.#invalidateTreeCache();
    if (this.#cursor) {
      this.#container?.removeChild(this.#cursor);
      this.#cursor = null;
    }
    this.#activeNode = null;
    this.#container = null;
    this.#itemTextLog = [];
    this.#spokenPhraseLog = [];
    this.#boundHandleFocusChange = null;
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-previous)
   *
   * Move the screen reader cursor to the previous location.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the previous item.
   *   await virtual.previous();
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async previous() {
    this.#checkContainer();
    await tick();
    const tree = this.#getModalAccessibilityTree();
    if (!tree.length) {
      return;
    }
    const currentIndex = this.#getCurrentIndex(tree);
    const nextIndex = currentIndex === -1 ? 0 : currentIndex - 1;
    const newActiveNode = tree.at(nextIndex);
    this.#updateState(newActiveNode);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-next)
   *
   * Move the screen reader cursor to the next location.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the next item.
   *   await virtual.next();
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async next() {
    this.#checkContainer();
    await tick();
    const tree = this.#getModalAccessibilityTree();
    if (!tree.length) {
      return;
    }
    const currentIndex = this.#getCurrentIndex(tree);
    const nextIndex = currentIndex === -1 || currentIndex === tree.length - 1 ? 0 : currentIndex + 1;
    const newActiveNode = tree.at(nextIndex);
    this.#updateState(newActiveNode);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-act)
   *
   * Perform the default action for the item in the Virtual Screen Reader cursor.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the next item.
   *   await virtual.next();
   *
   *   // Perform the default action for the item.
   *   await virtual.act();
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async act() {
    this.#checkContainer();
    await tick();
    if (!this.#activeNode) {
      return;
    }
    const target = getElementNode(this.#activeNode);
    await import_user_event.userEvent.click(target, defaultUserEventOptions);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-interact)
   *
   * No-op to provide same API across screen readers.
   *
   * The Virtual Screen Reader does not require users to perform an additional
   * command to interact with the item in the Virtual Screen Reader cursor.
   */
  async interact() {
    this.#checkContainer();
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-stop-interacting)
   *
   * No-op to provide same API across screen readers.
   *
   * The Virtual Screen Reader does not require users to perform an additional
   * command to interact with the item in the Virtual Screen Reader cursor.
   */
  async stopInteracting() {
    this.#checkContainer();
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-press)
   *
   * Press a key on the active item.
   *
   * `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
   * value or a single character to generate the text for. A superset of the `key` values can be found
   * [on the MDN key values page](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:
   *
   * `F1` - `F20`, `Digit0` - `Digit9`, `KeyA` - `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
   * `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.
   *
   * Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta` (OS permitting).
   *
   * Holding down `Shift` will type the text that corresponds to the `key` in the upper case.
   *
   * If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
   * texts.
   *
   * Shortcuts such as `key: "Control+f"` or `key: "Control+Shift+f"` are supported as well. When specified with the
   * modifier, modifier is pressed and being held while the subsequent key is being pressed.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Open a find text modal.
   *   await virtual.press("Command+f");
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @param {string} key Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
   */
  async press(key) {
    this.#checkContainer();
    await tick();
    if (!this.#activeNode) {
      return;
    }
    const rawKeys = key.replace(/{/g, "{{").replace(/\[/g, "[[").split("+");
    const modifiers = [];
    const keys = [];
    rawKeys.forEach((rawKey) => {
      if (typeof MacOSModifiers[rawKey] !== "undefined" || typeof WindowsModifiers[rawKey] !== "undefined") {
        modifiers.push(rawKey);
      } else {
        keys.push(rawKey);
      }
    });
    const keyboardCommand = [
      ...modifiers.map((modifier) => `{${modifier}>}`),
      ...keys.map((key2) => `{${key2}}`),
      ...modifiers.reverse().map((modifier) => `{/${modifier}}`)
    ].join("");
    this.#focusActiveElement();
    await import_user_event.userEvent.keyboard(keyboardCommand, defaultUserEventOptions);
    await this.#refreshState(true);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-type)
   *
   * Type text into the active item.
   *
   * To press a special key, like `Control` or `ArrowDown`, use `virtual.press(key)`.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Type a username and key Enter.
   *   await virtual.type("my-username");
   *   await virtual.press("Enter");
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @param {string} text Text to type into the active item.
   */
  async type(text) {
    this.#checkContainer();
    await tick();
    if (!this.#activeNode) {
      return;
    }
    const target = getElementNode(this.#activeNode);
    await import_user_event.userEvent.type(target, text, defaultUserEventOptions);
    await this.#refreshState(true);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-perform)
   *
   * Perform a Virtual Screen Reader command.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Perform action to move to the next landmark.
   *   await virtual.perform(virtual.commands.moveToNextLandmark);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @param {string} command Screen reader command.
   * @param {object} [options] Command options.
   */
  async perform(command, options) {
    this.#checkContainer();
    await tick();
    const tree = this.#getModalAccessibilityTree();
    if (!tree.length) {
      return;
    }
    const currentIndex = this.#getCurrentIndex(tree);
    const nextIndex = commands[command]?.({
      ...options,
      // `this.#checkContainer();` above null guards us here.
      container: this.#container,
      currentIndex,
      tree
    });
    if (typeof nextIndex !== "number") {
      return;
    }
    const newActiveNode = tree.at(nextIndex);
    this.#updateState(newActiveNode);
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-click)
   *
   * Click the mouse.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Left-click the mouse.
   *   await virtual.click();
   *
   *   // Left-click the mouse using specific options.
   *   await virtual.click({ button: "left", clickCount: 1 });
   *
   *   // Double-right-click the mouse.
   *   await virtual.click({ button: "right", clickCount: 2 });
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @param {object} [options] Click options.
   */
  async click({ button = "left", clickCount = 1 } = {}) {
    this.#checkContainer();
    await tick();
    if (!this.#activeNode) {
      return;
    }
    const key = `[Mouse${button[0].toUpperCase()}${button.slice(1)}]`;
    const keys = key.repeat(clickCount);
    const target = getElementNode(this.#activeNode);
    await import_user_event.userEvent.pointer(
      [{ target }, { keys, target }],
      defaultUserEventOptions
    );
    return;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-last-spoken-phrase)
   *
   * Get the last spoken phrase.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the next item.
   *   await virtual.next();
   *
   *   // Get the phrase spoken by the Virtual Screen Reader from moving to the next item above.
   *   const lastSpokenPhrase = await virtual.lastSpokenPhrase();
   *   console.log(lastSpokenPhrase);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @returns {Promise<string>} The last spoken phrase.
   */
  async lastSpokenPhrase() {
    this.#checkContainer();
    await tick();
    return this.#spokenPhraseLog.at(-1) ?? "";
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-item-text)
   *
   * Get the text of the item in the Virtual Screen Reader cursor.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move to the next item.
   *   await virtual.next();
   *
   *   // Get the text (if any) for the item currently in focus by the Virtual
   *   // screen reader cursor.
   *   const itemText = await virtual.itemText();
   *   console.log(itemText);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @returns {Promise<string>} The item's text.
   */
  async itemText() {
    this.#checkContainer();
    await tick();
    return this.#itemTextLog.at(-1) ?? "";
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-spoken-phrase-log)
   *
   * Get the log of all spoken phrases for this Virtual Screen Reader instance.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move through several items.
   *   for (let i = 0; i < 10; i++) {
   *     await virtual.next();
   *   }
   *
   *   // Get the phrase spoken by the Virtual Screen Reader from moving through the
   *   // items above.
   *   const spokenPhraseLog = await virtual.spokenPhraseLog();
   *   console.log(spokenPhraseLog);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @returns {Promise<string[]>} The spoken phrase log.
   */
  async spokenPhraseLog() {
    this.#checkContainer();
    await tick();
    return this.#spokenPhraseLog;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-item-text-log)
   *
   * Get the log of all visited item text for this Virtual Screen Reader instance.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // Move through several items.
   *   for (let i = 0; i < 10; i++) {
   *     await virtual.next();
   *   }
   *
   *   // Get the text (if any) for all the items visited by the Virtual screen
   *   // reader cursor.
   *   const itemTextLog = await virtual.itemTextLog();
   *   console.log(itemTextLog);
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   *
   * @returns {Promise<string[]>} The item text log.
   */
  async itemTextLog() {
    this.#checkContainer();
    await tick();
    return this.#itemTextLog;
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-clear-spoken-phrase-log)
   *
   * Clear the log of all spoken phrases for this Virtual Screen Reader
   * instance.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // ... perform some commands.
   *
   *   // Clear the spoken phrase log.
   *   await virtual.clearSpokenPhraseLog();
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async clearSpokenPhraseLog() {
    this.#checkContainer();
    await tick();
    this.#spokenPhraseLog = [];
  }
  /**
   * [API Reference](https://www.guidepup.dev/docs/api/class-virtual#virtual-clear-item-text-log)
   *
   * Clear the log of all visited item text for this Virtual Screen Reader
   * instance.
   *
   * ```ts
   * import { virtual } from "@guidepup/virtual-screen-reader";
   *
   * test("example test", async () => {
   *   // Start the Virtual Screen Reader.
   *   await virtual.start({ container: document.body });
   *
   *   // ... perform some commands.
   *
   *   // Clear the item text log.
   *   await virtual.clearItemTextLog();
   *
   *   // Stop the Virtual Screen Reader.
   *   await virtual.stop();
   * });
   * ```
   */
  async clearItemTextLog() {
    this.#checkContainer();
    await tick();
    this.#itemTextLog = [];
  }
};

// src/index.ts
var virtual = new Virtual();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Virtual,
  virtual
});
//# sourceMappingURL=index.cjs.map