"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.voiceOverTest = void 0;
const test_1 = require("@playwright/test");
const guidepup_1 = require("@guidepup/guidepup");
const applicationNameMap_1 = require("./applicationNameMap");
const voiceOverPlaywright = guidepup_1.voiceOver;
/**
 * These tests extend the default Playwright environment that launches the
 * browser with a running instance of the VoiceOver screen reader for MacOS.
 *
 * A fresh started VoiceOver instance `voiceOver` is provided to each test.
 */
exports.voiceOverTest = test_1.test.extend({
    voiceOverStartOptions: {},
    voiceOver: async ({ browserName, page, voiceOverStartOptions }, use) => {
        try {
            const applicationName = applicationNameMap_1.applicationNameMap[browserName];
            if (!applicationName) {
                throw new Error(`Browser ${browserName} is not installed.`);
            }
            voiceOverPlaywright.navigateToWebContent = async () => {
                // Ensure application is brought to front and focused.
                await (0, guidepup_1.macOSActivate)(applicationName);
                // Ensure the document is ready and focused.
                await page.bringToFront();
                await page.locator("body").waitFor();
                await page.locator("body").focus();
                // Navigate to the beginning of the web content.
                await voiceOverPlaywright.interact();
                await voiceOverPlaywright.perform(voiceOverPlaywright.keyboardCommands.jumpToLeftEdge);
                // Clear out logs.
                await voiceOverPlaywright.clearItemTextLog();
                await voiceOverPlaywright.clearSpokenPhraseLog();
            };
            await voiceOverPlaywright.start(voiceOverStartOptions);
            await (0, guidepup_1.macOSActivate)(applicationName);
            await use(voiceOverPlaywright);
        }
        finally {
            try {
                await voiceOverPlaywright.stop();
            }
            catch {
                // swallow stop failure
            }
        }
    },
});
